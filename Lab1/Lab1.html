<!--Лаба1 - Сайт с хабра с использованием HTML и CSS-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Теория вычислений. Введение в конечные автоматы</title>
    <link rel="stylesheet" href="C:\Users\mav_s\Desktop\Web\Lab1.css">
  </head>
  <body>
    <div id="header">
      Хабр
      <span id="ForAuthors">Как стать автором</span>
    </div>
    <div id="registration">
      <label for="login">Логин:</label><br>
      <input type="text" name="login" placeholder="Введите логин"><br><br>
      <label for="password">Пароль:</label><br>
      <input type="password" name="password" placeholder="Введите пароль"><br>
      <input type="button" name="OK" value="Войти" id="buttonOK">
    </div>
    <div id="main">
    <h2>Конечные автоматы (finite-state machine)</h2>
    <p>
      <p>Это до предела упрощенная модель компьютера имеющая конечное число состояний, которая жертвует всеми
        особенностями компьютеров такие как ОЗУ, постоянная память, устройства ввода-вывода и процессорными
        ядрами в обмен на простоту понимания, удобство рас­суждения и легкость программной или аппаратной реализации.
       </p>

      <p>С помощью КА можно реализовать такие вещи как, регулярные выражения, лексический анализатор, ИИ в играх и тд.</p>

      <p>У конечных автоматов имеется <b>таблица переходов, текущее состояние автомата, стартовое состояние и заключительное состояние</b>.</p>

      <p><b>Таблица переходов</b> — В ней хранятся переходы для текущего состояния и входного символа.<br>
         Простейшая реализация может быть как двумерный массив.</p>
         <div class="MiliRef">Пример 1 </div>
  <ul>
    <li>По горизонтали вверху находятся возможные входные символы.</li>
    <li>По вертикали слева находятся текущие возможные состояния.</li>
  </ul>
  <img src="https://habrastorage.org/webt/yk/ot/sw/ykotsw2ycozzk0jl-befj4gqesc.png" alt="image" width="200px"> <br>

      <p><i>Здесь видно, что из состояния 0 в состояние 1 можно попасть только, если у нас будет входной символ 'a', из состояния 1 в состояние 2, если символ 'b'.</i></p>
<p><b>Текущее состояние</b> — множество состояний в котором автомат может находиться в данный момент времени.</p>
<p><b>Стартовое состояние</b> — состояние откуда КА начинает свою работу.</p>
<p><b>Заключительное состояние</b> — множество состояний в которых автомат принимает определенную цепочку символов, в ином случае отвергает.</p>
    <h2>Детерминированные конечные автоматы (deterministic finite automaton)</h2>
<p>Простейший КА, в котором может быть одно состояние в текущий момент времени, обладает детерминированностью.</p>

<p><b>Детерминированность</b> — для всех состояний имеется максимум и минимум одно правило для любого возможного входного символа, то есть например, для состояния 1 не может быть два перехода с одним и тем же входным символом.</p>

<div class="MiliRef">
  Пример 2
</div>
<img src="https://habrastorage.org/webt/og/hp/ep/oghpepiuspqbszqpmvsuwgvvelc.png" alt="Image" width="350px"><br>
<p> <i>Здесь изображена диаграмма переходов для ДКА, визуализация примера 1. Состояние 3 является заключающим.
   По диаграмме видно, что ДКА принимает цепочку символов только в том случае, если будет последовательность
   из символов 'a', 'b' и 'c'. </i> </p>
<h2>Недетерминированные конечные автоматы (nondeterministic finite automaton)</h2>
<p>НКА не является каким-то существенным улучшением ДКА, просто в нем добавлен так сказать синтаксический сахар,
  в виде <b>свободных переходов, недетерминированности и множеств состояний</b>. Реализовать можно как массив состоящий
  из структур в которой хранится состояние, входной символ и следующее состояние.</p>

<div class="MiliRef">
      Реализация НКА
</div>
<code>
  <pre>// Ячейка массива состоящая из: текущее_состояние, считаный_символ, следующее_состояние.
struct state {
	unsigned char current;
	signed char sym; // signed, для обозначения свободного перехода как -1.
	unsigned char next;
};

// Таблица переходов для НКА на примере 2
struct state machine[] = {
	{0, 'a', 1},
	{1, 'a', 1},
	{2, 'a', 1},
	{1, 'b', 2},
	{2, 'c', 3}
};</pre>
</code>
<p><b>Свободные переходы (эпсилон переходы)</b> — переходы, которые можно совершать без чтения входного символа.</p>
<p><b>Недетерминированность</b> — ноль и более переходов для одного символа в каких-либо состояниях.</p>
<p><b>Множества состояний</b> — в один момент времени НКА может находится в нескольких состояниях.</p>
      <div class="MiliRef">
        Пример 3
      </div>
      <p> <i>Заключительное состояние обозначается двойным кругом.</i> </p>
      <img src="https://habrastorage.org/webt/3_/8m/w5/3_8mw5lwag_jlh14m4gmy9bk6ra.png" alt="Image" width="400px">
            <p> <i>В стартовом состоянии у нас текущим состоянием является {1}, при входном символе 'b' у нас
               появляется возможность, пойти в состояние 1 и в состояние 2, то есть после входного символа 'b'
               текущим состоянием является множество {1, 2}.</i> </p>
      <div class="MiliRef">
        Пример 4
      </div>
      <p> <i>Свободным переходом обозначается пунктирной линией</i> </p>
      <img src="https://habrastorage.org/webt/6p/jd/yr/6pjdyryxsi7-1g7ysd8tnqynyt8.png" alt="Image" width="300px">
      <p> <i>Здесь видно два свободных перехода из стартового состояния, то есть без чтения входного символа мы
         сразу находимся в множестве состоянии {2, 4}.</i> </p>
         <p>Для преобразования НКА в ДКА используется <a href="https://neerc.ifmo.ru/wiki/index.php?title=Построение_по_НКА_эквивалентного_ДКА,_алгоритм_Томпсона">
           алгоритм Томпсона</a>.<br>
         При преобразовании НКА в ДКА может получиться не совсем минимальный ДКА и для его минимизации можно применить
         <a href="http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D1%80%D0%B6%D0%BE%D0%B7%D0%BE%D0%B2%D1%81%D0%BA%D0%BE%D0%B3%D0%BE">
           алгоритм Бржозовского</a>.</p>

<h2>Конечные автоматы с магазинной памятью (pushdown automaton)</h2>

<p>Это тот же КА, но с дополнительной памятью в виде стека. Теперь для совершения перехода нужно учитывать еще несколько факторов,
  символ который нужно <b>удалить из стека</b> и символы которые нужно <b>добавить в стек</b>.</p>
      <p>КАМП можно применять в таких местах, где может быть неограниченное количество вложений, например при разборе языков
         программирование или подсчету вложенных скобок в математических выражениях. Реализовать с помощью КА невозможно, ведь
         количество возможных состояний конечно в отличие от стека (я понимаю, что память тоже конечна).</p>

      <p><b>Удаление символа из стека</b> — при любом переходе решается какой символ вытолкнуть, если на вершине стека не оказалось
         такого символа, то он и не выталкивается. Так же если символ нужно оставить в стеке, то он добавляется вместе с добавляемыми
          символами.</p>

<p><b>Добавление символов в стек</b> — при любом переходе решает какие символы добавить в стек.</p>
      <p> <b>Виды:</b> </p>
<ol>
  <li><b>Детерминированные</b> — к нему применяются те же правила как к ДКА к тому же завершает работу только в заключительном
     состоянии.</li>
     <li><b>Недетерминированные</b> — к нему применяются те же правила как к НКА к тому же он может завершать работу в заключительном
        состоянии или когда стек станет пуст.</li>
</ol>
<div class="MiliRef">
  Пример 5
</div>
<p> <i>Шаблон: входной_символ; удаляемый_символ/добавляемый символ. На дно стека добавляется символ $ для, того, что понять когда он
   закончился</i> </p>
      <img src="https://habrastorage.org/webt/1v/fv/rd/1vfvrdlbcj_tjmarz0r1o9bp9vy.png" alt="Image" width="300px">
      <p> <i>Этот КАМП подсчитывает вложенность скобок, за счет добавления и удаления символов из стека.</i> </p>
<p>ДАМП не равен НАМП, поэтому невозможно одно преобразовать в другое, следовательно НАМП обладает преимуществом перед ДАМП.</p>

<h2>Машина Тьюринга (Turing machine)</h2>

<p>Самая мощная машина из существующих, его преимущество перед другими в ленте с которой он может работать как хочет.
  В нем нет свободных переходов. Умеет интерпретировать другие автоматы такие как КА, КАМП.</p>
    <p><b>Лента</b> — это одномерный массив в который могут записываться данные за счет головки над ячейкой, который можно заранее заполнить входными данными.</p>
<div class="MiliRef">
  Пример 6
</div>
<p> <i>Шаблон: считаный_символ_с_головки/записаный_символ; сторона_смещения_головки. края ленты обозначаются '_'.</i> </p>
<img src="https://habrastorage.org/webt/ye/n6/rm/yen6rmxedzmxkvmsffhd2wcu0q4.png" alt="Image" width="300px">
<i><p>Эта МТ выполняет инкремент двоичного числа, головка стоит слева, там где начинается лента.</p>
<p>Выполнение:</p>
<ol>
  <li>Если находится в состоянии 1 и прочитан нуль, записать еди­ницу, сдвинуть вправо и перейти в состояние 2.</li>
  <li>Если находится в состоянии 1 и прочитана единица, записать нуль, сдвинуть влево и перейти в состояние 1.</li>
  <li>Еcли находится в состоянии 1 и прочитан пустой квадратик, записать единицу, сдвинуть вправо и перейти в состояние 2.</li>
  <li>Если находится в состоянии 2 и прочитан нуль, записать нуль, сдвинуть вправо и остаться в состояние 2.</li>
  <li>Если находится в состоянии 2 и прочитана единица, записать единицу, сдвинуть вправо и остаться в состояние 2.</li>
  <li>Если находится в состоянии 2 и прочитать пустой квадратик, записать пустой квадратик, сдвинуть влево и перейти в состоя­ние 3.</li>
</ol>
</i>
<p>ДМТ эквивалентен НМТ, так, что они тоже не различаются.</p>

<h2>Универсальная машина Тьюринга (universal Turing machine)</h2>

<p>Машина которая может порождать другие машины Тьюринга, получая на входную ленту данные машины.</p>
  <p> <b>Недостатки:</b> </p>
<ol>
  <li>Память порождаемой машины не может быть больше, чем у самой УМТ.</li>
  <li>Нужно уметь правильно разделять пространство ленты между порождаемой машиной и УМТ, ведь их данные находятся на одной ленте.</li>
</ol>
<p>На этом введение в автоматы закончено, теперь вы можете продолжить изучать дальнейший материал сами.</p>

<p> <b>Литература:</b> </p>
<p>
      <ul>
        <li> <a href="https://www.amazon.com/Understanding-Computation-Machines-Impossible-Programs/dp/1449329276/ref=sr_1_5?s=books&ie=UTF8&qid=1525978527&sr=1-5&refinements=p_27%3ATom+Stuart">
          «Теория вычислений для программистов», Том Стюарт.</a> </li>
      </ul>
</p>

  </div>
  </body>
</html>
